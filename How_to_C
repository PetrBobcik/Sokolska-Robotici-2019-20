Datové typy
int    -> celé číslo (integer)
char   -> znak (1Byte) 
float  -> desetinné číslo
double -> desetinné číslo s větší přesností
bool   -> pravdivostní hodnota (boolean - pravda/nepravda)

Výraz
x = 0

Příkaz
x = 0;

Proměnná
Pojmenovaný kus paměti. Bez něj bychom museli počítat s adresou, offsetem,... Takto nám stačí použít pouze jméno.
Datový_typ jméno_proměnné = hodnota; 
Př.: int promenna = 0;
Pokud se proměnná používá, například v podmínce,... tak se k ní datový typ nenpíše. Datový typ se tam píše jen při vytváření.

Deklarace proměnné
int x; 

Definice proměnné
int x = 0;    Proměnná x je typu celé číslo a vložili jsme do ní hodnotu 0

Komentář
Komentáře se při překladu vyhazují (nepřekládají se). Jedná se pouze o info pro programátora.
// -> jednořádkový komentář
/* více řádkový komentář */

příklad.:
// zakomentoval se pouze tento řádek
/* zakomentoval jsem tento řádek
   tento řádek
   i tento řádek
*/


Podmíněný příkaz
if      -> použijeme, pokud chceme, aby se podmínka vždy zkontrolovala; if musí předcházet else ifu i else-> musí být prostě první
else if -> použijeme, pokud chceme, aby se podmínka zkontrolovala jen pokud předchozí if a else if nebyly splněné
else    -> pokdu se ani if ani else if nesplní, provede se -> neobsahuje podmínkovou část

Složený příkaz
{} -> umožňuje u podmínek použít více jak 1 příkaz -> za složenými závorkami se středník nepíše, ale píše se za každým příkazem v něm 
 
příklad.:
  if(podmínka)
    tento příkaz, se provede po splnění podmínky ;
  tento příkaz se provede i když není podmínka splněná ;
  
  if(podmínka)
    tento příkaz, se provede po splnění podmínky ;
    tento příkaz se provede i když není podmínka splněná ;
  
  if(podmínka){
    tento příkaz, se provede po splnění podmínky ;
    tento příkaz, se provede po splnění podmínky ;
  }
  
Vnořené podmínky
if(podmínka){ 
  if(podmínka){ -> podmínka vnořená do podmínky na řádku 46, její podmínka se zkontroluje, jen pokud bude podmínka na řádku 46 splněna
    if(podmínka){ -> podmínka vnořená do podmínky na řádku 47, její podmínka se zkontroluje, jen pokud bude podmínka na řádku 46 a
                     zároveň na řádku 48 splněna
    }
  }
}
else if(podmínka){ -> na stejné úrovni, jako podmínka na řádku 46, ale podmínka se zkontroluje jen pokud se nesplňí podmínka na řádku 46
}

Formátování
Cokoliv vnořeného se automaticky tabulátoruje (TAB), například:
if(podmínka)
  odtabulovaný příkaz;
Podmínky,... na stejné úrovni jsou stejně odtabulátorované, například.:
if(podmínka)
  něco;
if(podmínka)
  něco;
  
Špatné formátovaní je například.:
if(podmínka)
  něco;
  if(podmínka)
    něco;
    
    nebo
    
if(podmínka)
  něco;
  if(podmínka)
  něco;
  
    atd.

Výpis na obrazovku
   funkce printf
   printf("text k vypsani typ_promenne_k_vypisu", promenna_k_vypisu);
 př.: printf("Promenna i ma hodnotu: %d\n", i);
                                      ^ ^
                                      | |____ odřádkuje, takže další print se vypíše na další řádek, jinak vedle sebe
                                      | 
                                      určuje typ proměnné = %d je celé číslo, %a je desetinné číslo (double)
                                                               %f je desetinné číslo (float), %c je znak, %s je
                                                               textový řetězec, %p je ukazatel, %x je hexadecimální
                                                               číslo,...
Pokud napíšu: printf("Promenna i ma hodnotu: \n"); , tak se proměnná nevypíše. Cokoliv je v "" se v této podobě vypíše.
Abyste vypsali přípo proměnnou, musíte přidat typ proměnné (%d, %f,...) a za uvozovky napsat proměnnou k vypsání.
printf("Promenna i ma hodnotu: %d\n", i);
                                    ^^^^
                                    ||||
                                    toto vypíše proměnnou i, která se výpíše jako celé číslo (%d)
Pokud chcete vypsat více proměnných, tak se typ přiřadí k následující proměnné, viz příklad níže.:
printf("Hodnoty: %d %d %d\n", a, b, c);
                  ^  ^  ^
                  a  b  c
                  
return -> ukončuje program s hodnotou, kterou jste přiřadili (pokud tuto hodnotu neřešíte, například
            pokud nemáte více programů naráz, tak ji volte 1 = nastal problém, 0 = vše dopadlo dobře)
př.: return 0;


16.10.2019
Ekvivalentné zápis
i=i+1;  -> i+=1; -> i++; -> ++i;
i=i-1;  -> i-=1; -> i--; -> --i;
Pokud chcete přičíst/odečíst jinou hodnotu než 1, tak můžete použít první dvě varianty: i = i + 23; nebo i+=23;
cyklus for
for( vytvoření_proměnné; podmínková_část; co_se_provede){
   blok příkazů, které se mají při každém průchodu splnit
}

př.:
for(int j = 10; j < 10;j+=2){
   printf("Variable i: ");    
}
