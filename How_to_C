Datové typy
int    -> celé číslo (integer)
char   -> znak (1Byte) 
float  -> desetinné číslo
double -> desetinné číslo s větší přesností
bool   -> pravdivostní hodnota (boolean - pravda/nepravda)

Výraz
x = 0

Příkaz
x = 0;

Proměnná
Pojmenovaný kus paměti. Bez něj bychom museli počítat s adresou, offsetem,... Takto nám stačí použít pouze jméno.
Datový_typ jméno_proměnné = hodnota; 
Př.: int promenna = 0;
Pokud se proměnná používá, například v podmínce,... tak se k ní datový typ nenpíše. Datový typ se tam píše jen při vytváření.

Deklarace proměnné
int x; 

Definice proměnné
int x = 0;    Proměnná x je typu celé číslo a vložili jsme do ní hodnotu 0

Komentář
Komentáře se při překladu vyhazují (nepřekládají se). Jedná se pouze o info pro programátora.
// -> jednořádkový komentář
/* více řádkový komentář */

příklad.:
// zakomentoval se pouze tento řádek
/* zakomentoval jsem tento řádek
   tento řádek
   i tento řádek
*/


Podmíněný příkaz
if      -> použijeme, pokud chceme, aby se podmínka vždy zkontrolovala; if musí předcházet else ifu i else-> musí být prostě první
else if -> použijeme, pokud chceme, aby se podmínka zkontrolovala jen pokud předchozí if a else if nebyly splněné
else    -> pokdu se ani if ani else if nesplní, provede se -> neobsahuje podmínkovou část

Složený příkaz
{} -> umožňuje u podmínek použít více jak 1 příkaz -> za složenými závorkami se středník nepíše, ale píše se za každým příkazem v něm 
 
příklad.:
  if(podmínka)
    tento příkaz, se provede po splnění podmínky ;
  tento příkaz se provede i když není podmínka splněná ;
  
  if(podmínka)
    tento příkaz, se provede po splnění podmínky ;
    tento příkaz se provede i když není podmínka splněná ;
  
  if(podmínka){
    tento příkaz, se provede po splnění podmínky ;
    tento příkaz, se provede po splnění podmínky ;
  }
  
Vnořené podmínky
if(podmínka){ 
  if(podmínka){ -> podmínka vnořená do podmínky na řádku 46, její podmínka se zkontroluje, jen pokud bude podmínka na řádku 46 splněna
    if(podmínka){ -> podmínka vnořená do podmínky na řádku 47, její podmínka se zkontroluje, jen pokud bude podmínka na řádku 46 a
                     zároveň na řádku 48 splněna
    }
  }
}
else if(podmínka){ -> na stejné úrovni, jako podmínka na řádku 46, ale podmínka se zkontroluje jen pokud se nesplňí podmínka na řádku 46
}

Formátování
Cokoliv vnořeného se automaticky tabulátoruje (TAB), například:
if(podmínka)
  odtabulovaný příkaz;
Podmínky,... na stejné úrovni jsou stejně odtabulátorované, například.:
if(podmínka)
  něco;
if(podmínka)
  něco;
  
Špatné formátovaní je například.:
if(podmínka)
  něco;
  if(podmínka)
    něco;
    
    nebo
    
if(podmínka)
  něco;
  if(podmínka)
  něco;
  
    atd.

Výpis na obrazovku
   funkce printf
   printf("text k vypsani typ_promenne_k_vypisu", promenna_k_vypisu);
 př.: printf("Promenna i ma hodnotu: %d\n", i);
                                      ^ ^
                                      | |____ odřádkuje, takže další print se vypíše na další řádek, jinak vedle sebe
                                      | 
                                      určuje typ proměnné = %d je celé číslo, %a je desetinné číslo (double)
                                                               %f je desetinné číslo (float), %c je znak, %s je
                                                               textový řetězec, %p je ukazatel, %x je hexadecimální
                                                               číslo,...
Pokud napíšu: printf("Promenna i ma hodnotu: \n"); , tak se proměnná nevypíše. Cokoliv je v "" se v této podobě vypíše.
Abyste vypsali přípo proměnnou, musíte přidat typ proměnné (%d, %f,...) a za uvozovky napsat proměnnou k vypsání.
printf("Promenna i ma hodnotu: %d\n", i);
                                    ^^^^
                                    ||||
                                    toto vypíše proměnnou i, která se výpíše jako celé číslo (%d)
Pokud chcete vypsat více proměnných, tak se typ přiřadí k následující proměnné, viz příklad níže.:
printf("Hodnoty: %d %d %d\n", a, b, c);
                  ^  ^  ^
                  a  b  c
                  
return -> ukončuje program s hodnotou, kterou jste přiřadili (pokud tuto hodnotu neřešíte, například
            pokud nemáte více programů naráz, tak ji volte 1 = nastal problém, 0 = vše dopadlo dobře)
př.: return 0;


16.10.2019
Ekvivalentné zápis
i=i+1;  -> i+=1; -> i++; -> ++i;
i=i-1;  -> i-=1; -> i--; -> --i;
Pokud chcete přičíst/odečíst jinou hodnotu než 1, tak můžete použít první dvě varianty: i = i + 23; nebo i+=23;

cyklus for - počítaný ciklus -> předem víme, kolikrát se má provést
Opakuje se, dokud je podmínka splněná.
for( vytvoření_proměnné; podmínková_část; co_se_provede){
   blok příkazů, které se mají při každém průchodu splnit
}

je ekvivalentní s

for( vytvoření_proměnné; podmínková_část; co_se_provede)
   blok příkazů, které se mají při každém průchodu splnit

př.:
for(int j = 10; j < 10;j+=2){ // opakuj se, DOKUD je 'j' menší než 10
   printf("Variable i: ");    
}

23.10.2019

Cyklus while - pracuje se s ním stejně, jako s for cyklem, ale v kulatých závorkách se proměnná nevytváří
               a ani se zde neprovádí akce napr.: i++, ... tyto věci musí být mimo
while(podmínka){
   příkaz;
   příkaz;
   příkaz;
   ...
}

příklad:
int i = 0;     --> vytvoření proměnné
while(i < 5){  --> podmínka
   printf("Cislo je: %d\n", i);
   i++;        --> akce
}
Tento cyklus vypise 5x text v printf().

Cyklus do while - stejný jako while, akorát se nejprve provede obsah složených závorek a až poté se zkontroluje
                  podmínka ve while
                - rozdíl oproti while je v tom, že se obsah složených závorek provede vždy alespoň jednou, zatímco
                  u while se nemusí provést ani jednou
do{
   příkaz;
   příkaz;
   příkaz;
   ...
}while(podmínka);

Modulo - zbytek po celočíselném dělení
Značí se - %
Příklad.:  1 / 2 = 0, ale  1 % 2 = 1
          -1 / 2 = 0, ale -1 % 2 = -1
Umožňuje vám vymezit interval - chci interval od 0 do 10, ale nevím, jaké číslo mi zadá uživatel,
                                tak provedeme - číslo_od_uživatele % 10   ->  1 % 10 je 1, 2 % 10 je 2,...
                                10 % 10 je 0, 11 % 10 je 1 atd...
Pomocí modulo můžeme zjistit, zda je danné číslo sudé / liché. Pokud modulo nějakého čísla dvojkou není 0, tak je liché,
příkladem je například.: 1 % 2 = 1, takže liché, ale 2 % 2 = 0, takže sudé.

Pole
Zatím jsem pracovali pouze s jednou proměnnou, ale co kdybychom si chtěli vytvořit jednu proměnnou, která by obsahovala více
hodnot naráz? Například pokud chcete uchovat věk 100 svých zaměstnanců, tak je přece hloupost vytváře 100 různých proměných 
stylu 
int zam1_vek;
int zam2_vek;
int zam3_vek;
int zam4_vek;
...
Proto existuje konstrukce zvaná pole. Jedná se o "n" prvků, uloženy za sebou v paměti. Datové typy jsou stené jako 
známe u proměnných (int, float, bool,...). 
Jak pole vypadá:
   datový_typ jméno_pole[ kolik_prvků_chceme ];
   
př.: int vek_zamestnance[100]; -> vytvořil jsem pole se 100 hodnotami a všechny typu celé číslo (int).
                               -> pole je takzvaně homogenní, takže v sobě může obsahovat pouze prvky
                                  stejného typu, takže nemůže být deset typu int, deset typu char, ...
                                  
Jak přistupovat k prvkům pole: 
   printf("vek prvniho zamestnance: %d",vek_zamestnance[0]); --> vypise vek prvniho zamestnance
     
   !!!!! Pole začíná na hodnotě 0, takže první prvek je na indexu 0 a poslední na 99, nikoli 100. !!!!!
   
Zápis do prvku pole je stejný jako u proměnné: vek_zamestnance[0] = 25; -> na první prvek pole jsme zapsali číslo 25
